%!TEX root = ../main.tex
\section{Embedded Design}
\todo[inline]{Thomas: Describe why the zybo is used!}
\todo[inline]{Thomas: Describe the encoders of the motor.}
An embedded system is needed to handle a wide range array. 
It is a requirement for the project that the Zybo board should be used as the embedded system in the project.
The board features a Zynq Z-7010 chip from Xilinx, which has an integrated dual-core ARM Cortex-A9 processor and a Xilinx 7-series field programmable gate array (FPGA).
The Zybo board itself consists among other of several buttons, switches, LEDs and connections for USB, Ethernet, HDMI and several PMOD connectors.

\subsection{Functionality}
An analysis of the complete system yielded the functionalities listed below for the Zybo board. 

\begin{itemize}
\item Digital inputs and outputs
\item Generating PWM
\item Measuring voltage output from LEM sensors
\todo[inline]{Thomas: it is a voltage being measured, but we are indirectly measuring a current?}
\item UART communication with external PC
\item Control algorithms for dq-control
\item Read position from encoder circuit
\end{itemize}

As can be seen on the list there are multiple different tasks that needs to be handled. 
By looking at them it can be seen that optimally they should be run at different speeds.
The PWM switching frequency should be 20kHz as described in section ????.
\todo[inline]{Thomas: Section that describes pwm switching losses?}
As this is quite fast it should be handled in the FPGA \todo[inline]{Thomas: Xilinx speak of PS and PL, the "FPGA part" is known as the PL (Programmable logic)} part of the Zynq chip. 
The rest can be handled on the ARM processor. 
In order to utilize that some tasks needs to be run at lower frequencies it was choosen to use khaOS which is a Run To Comple Scheduler (RTCS) system made by Karsten Holm Andersen.
\todo[inline]{Thomas: Are there any papers on khaOS that we could reference?}
Using an RTCS makes it easy to schedule tasks to run at different frequencies. 
As an RTCS has no way to preempt tasks it leaves much responsibility to the programmer in order to preserve the real time performance of the system.
When the software is finished tests should be performed to ensure  the real time performance.
khaOS was chosen before other RTCS as the group had knowledge about the system from an Embedded Systems course.

\subsection{Architecture}
The software functionalities was grouped into tasks based on functionality and desired frequency.
A task diagram of the complete system on the Zybo can be seen in figure \ref{fig:task_diagram}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=1\linewidth]{graphics/TaskDiagram}
	\caption[Task diagram.]{Task diagram of the complete system on the Zybo. Inside ARM rectangle circles are separate tasks while boxes are shared variables. In the FPGA area all the FPGA components are shown. Outside the rectangle all the signals to and from the outside world are shown.}
	\label{fig:task_diagram}
\end{figure}
\todo[inline]{Thomas: Task diagram seems like it could be slightly smaller without any problems, signals from 3 phase pwm generator to world}
\todo[inline]{Thomas: Task diagram: LEDs, no reason to write Pinx3, UART RX = UART receive, UART TX = UART Transmit, Vsq\_ref+Vsd\_ref stretch to fit entire word on one line, Censor = Sensor. Also, the TX/RX buffers should be labeled to match the text}
\todo[inline]{Thomas: Task diagram: The distinction between PL, PS and world is not clear}
\todo[inline]{add ARM label. Add RX/TX buffer. text to tx. -Mikkel}
As can be seen various signals are coming from the outside world through the FPGA into the ARM processor.
The signals from the current sensors and the the pedal will go to the ADC on the Zybo board. 
The ADC task will poll values from the ADC registers and update the $I_a$,$I_b$ and Torque reference variables.  
The UART RX and UART TX tasks are simply tasks that handle communication to a connected computer through the UART protocol.
UART TX task will read from the TX buffer and transmit the data, while the UART RX will read data coming from the connected computer and put it in the RX buffer.



\subsubsection{PWM generator}
The PWM generator is placed in the FPGA and is developed using Xilinx System Generator in Matlab Simulink.
The PWM generator is made to have an adjustable frequency and dutycycle.
It was choosen to make a center aligned PWM generator as this introduces less harmonic distortion than edge aligned PWM \cite{power_switching_converters}. 
Furthermore center aligned PWM also produces a symmetrical PWM signal, with a defined midpoint in the PWM-wave where the current can be sampled correctly.
The high limit for the counter can to be calculated for a given frequency, $f$, by the following:
$$H = L + \frac{f_{Zybo}}{f\cdot 2}$$
Where H is the high limit, L is the low limit and $f_{zybo}$ is the clock frequency of the Zynq-7010. 
The PWM counter system can be seen in figure \ref{fig:pwm_counter}.
The counter block will count up or down depending on the input. 
The output from the counter value will go into to two compare blocks along with the high and low limits.
The compare blocks will produce a high signal when the counter value is equal to the high and low limit respectively.
These signals are then fed to a an m-code blocks which contains a simple state machine which determines if the counter should count up or down.
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{graphics/counter}
	\caption[Block diagram of counter in PWM generator.]{Simulink block diagram of the counter in the PWM generator.}
	\label{fig:pwm_counter}
\end{figure}
The counter out signal can be seen in figure \ref{fig:pwm_graph}.
The counter signal is then fed into a PWM mechanism shown in figure \ref{fig:pwm}. 
The dutycycle is given to the PWM generator in the datatype u32, an integer type and therefore the dutycycle is given in a range of 0 to 1000, giving a resolution of 0.1\%.
The switching limit will be calculated from the following:
$$l = (1 - \frac{d}{1000}) \cdot r$$
Where l is switching limit, d is the dutycycle in the range 0 - 1000 and is the counter range.
A register will then make sure that the switching limit is only passed on when the counter is at its lowest.
It is important to do so as otherwise the dutycycle can be corrupted.
The compare block will make the PWM signal by comparing the switcing limit to the counter value.
The counter signal and output of the PWM generator can be seen in figure \ref{fig:pwm_graph}.
As the PWM generator should be able to do three independent PWM signal there are three of the systems shown in figure \ref{fig:pwm}, one for each phase.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{graphics/pwm_system}
	\caption[Block diagram of PWM generator.]{Simulink block diagram of the PWM mechanism in the PWM generator.}
	\label{fig:pwm}
\end{figure}


\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=\linewidth]{graphics/pwm_plot}
		\caption{Counter and PWM signal.}
		\label{fig:pwm_graph}
	\end{center}
\end{figure}

\subsubsection{PWM task}
The PWM tasks basic functionality can be seen in the block diagram of figure \ref{fig:pwm_task}.
The PWM task is a seperate task from the controller task as it might be preferrable to have the two tasks run at different frequencies.
It is responsible for performing inverse Clarke Park transformation using $V_{sd}$, $V_{sq}$ and $\theta$. 
Afterwards the calculated dutycycles will be written to the PWM generator in the FPGA if the enable signal is high.

\begin{figure}[!h]
	\centering
		\includegraphics[width=0.9\linewidth,trim=2cm 17cm 0cm 4cm]{graphics/pwm_tasktikz}
	\caption[Block diagram of PWM task.]{Block diagram showing the functionality of the PWM task.}
	\label{fig:pwm_task}
\end{figure}

\todo[inline]{Where should we talk about the concept of dq and the meaning of it? -MIkkel}
\todo[inline]{Third harmonic injection and why? -MIkkel}


\subsubsection{Interface task}
The interface task is the task that has to read external signals, output digital signals and control the other tasks.
The UART tasks will be controlled through two buffers, while the controller and PWM task will have to read the enable variable updated by the interface task.
The basic funcionality of the interface task can be seen in the flowchart of figure \ref{fig:interface}.
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{graphics/interface_task}
	\caption[Block diagram of PWM generator.]{Simulink block diagram of the counter in the PWM generator.}
	\label{fig:interface}
\end{figure}
\todo[inline]{Can there be less whitespace in the figure? -MIkkel}
\todo[inline]{Is the inrush relay explained somewhere?? -MIkkel}

\subsubsection{Controller task}
The controller tasks basic functionality can be seen in figuer \ref{fig:controller_task}.
It reads from the variables $I_a$ and $I_b$ and calculates $I_c$. 
$I_a$, $I_b$, $I_c$ and $\theta$ are then used to perform a Clarke Park transformation. 
$I_d$ and $I_q$ are then controlled with two seperate PI controllers. 
$I_d$ is controlled with reference $0$ and $I_q$ is controlled with the pedal as reference.

\begin{figure}[!h]
	\centering
		\includegraphics[width=0.9\linewidth,trim=3cm 15cm 0 2cm]{graphics/controller_tasktikz}
	\caption[Block diagram of controller task.]{Block diagram showing the functionality of the controller task.}
	\label{fig:controller_task}
\end{figure}

\subsubsection{ADC}
The Zynq chip contains a dual 12-bit, 1 Mega sample per second (MSPS) Analog-to-Digital Converter (ADC) \cite{adc}.
The ADC is utilized through the XADC Wizard in Vivado. 
The ADC measures the difference between differential analog input pins $V_p$ and $V_n$.
The IP core is configured to use AXI4LITE connection, simultaneous selection, unipolar mode and event mode.
Simultaneous selection mode is used as it allows simultaneous sampling on the dual ADC. 
When using simultaneous sampling the phase relationship is preserved.
When unipolar mode is enabled the input range between $V_p$ and $V_n$ is 1 \si{\volt} and the input voltage must always be positive.
Setting the ADC in event mode, means that the ADC will only sample when there is a rising edge on its CONVST pin. 
The CONVST pin is connected to the top signal of the PWM generator meaning that the ADC will sample in the center of the PWM pulse.
This is done to avoid sampling any current spikes. 
Channels 6 and 14 are paired together in simultaneous mode, meaning that they will be sampled simultaneous.
Therefore the outputs from the two LEM sensors will be connected to these. 
The torque pedal signal will be routed to channel 7 which will be sampled after channel 6 and 14.
The top signal from the PWM generator will start the sampling and therefore it will also set the sampling frequency.
As the PWM frequency is 20 \si{\kilo\hertz} the PWM frequency will be so as well.
\todo[inline]{Will all channels be sampled on rising edge on CONVST pin? - Mikkel}

\subsection{Encoder}
The Zybo board needs to interface the RMB28MD encoder that is mounted on the motor.
The RMB28MD is an absolute encoder with sine/cosine, SSI and incremental output. 
It was choosen to use the SSI output as an IP core reading the position by SSI communication was made available by the supervisors of the group.
Reading the position throug SSI yields a resolution of 8bit per mechanical revolution. 
The IP core outputs a clock to the RMB28MD chip and reads data from a datapin. 
It then makes the data available on the AXI4LITE bus, where it can be read from software. 

\subsection{SPI communication}

\begin{figure}[!h]
	\centering
		\includegraphics[width=1\linewidth]{graphics/spi_timing}
	\caption[SPI timing requirements.]{SPI timing requirements.From datasheet? How to cite?}
	\label{fig:spi_timing}
\end{figure}

\begin{figure}[!h]
	\centering
		\includegraphics[width=1\linewidth]{graphics/spi}
	\caption[SPI communication.]{SPI communication from scope...}
	\label{fig:spi_graph}
\end{figure}



\subsection{TEST or whatever}

%\subsection{Conclusion}