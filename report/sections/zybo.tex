%!TEX root = ../main.tex
\section{Embedded Design}\label{sec:Embedded_Design}
\todo[inline]{Thomas: Describe the encoders of the motor.}
An embedded system is needed to handle a wide range of task. 
It is a requirement for the project that the Zybo board should be used as the embedded system in the project.
The board features a Zynq Z-7010 chip from Xilinx, which has an integrated dual-core ARM Cortex-A9 processor and a Xilinx 7-series field programmable gate array (FPGA).
The Zybo board itself consists among other of several buttons, switches, LEDs and connections for USB, Ethernet, HDMI and several PMOD connectors. 
Furtheron the FPGA part will be referred to as the Programmable Logic (PL) and the ARM processor as the Processing System (PS). 


\subsection{Functionality}
An analysis of the complete system yielded the functionalities listed below for the Zybo board. 

\begin{itemize}
\item Digital inputs and outputs
\item Generating PWM
\item Measuring voltage output from LEM sensors
\todo[inline]{Thomas: it is a voltage being measured, but we are indirectly measuring a current?}
\item UART communication with external PC
\item Control algorithms for dq-control
\item Read position from encoder circuit
\item SPI communication as master
\end{itemize}

As can be seen on the list there are multiple different tasks that needs to be handled. 
By looking at them it can be seen that optimally they should be run at different speeds.
The PWM switching frequency should be 20kHz as described in section ????.
\todo[inline]{Thomas: Section that describes pwm switching losses?}
As this is quite fast it should be handled in the FPGA \todo[inline]{Thomas: Xilinx speak of PS and PL, the "FPGA part" is known as the PL (Programmable logic)} part of the Zynq chip. 
The rest can be handled on the ARM processor. 
In order to utilize that some tasks needs to be run at lower frequencies it was choosen to use khaOS which is a Run To Comple Scheduler (RTCS) system made by Karsten Holm Andersen.
\todo[inline]{Thomas: Are there any papers on khaOS that we could reference?}
Using an RTCS makes it easy to schedule tasks to run at different frequencies. 
As an RTCS has no way to preempt tasks it leaves much responsibility to the programmer in order to preserve the real time performance of the system.
When the software is finished tests should be performed to ensure  the real time performance.
khaOS was chosen before other RTCS as the group had knowledge about the system from an Embedded Systems course.

\subsection{Architecture}
The software functionalities was grouped into tasks based on functionality and desired frequency.
A task diagram of the complete system on the Zybo can be seen in figure \ref{fig:task_diagram}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=1\linewidth]{graphics/TaskDiagram}
	\caption[Task diagram.]{Task diagram of the complete system on the Zybo. Inside ARM rectangle circles are separate tasks while boxes are shared variables. In the FPGA area all the FPGA components are shown. Outside the rectangle all the signals to and from the outside world are shown.}
	\label{fig:task_diagram}
\end{figure}
\todo[inline]{Thomas: Task diagram: Vsq\_ref+Vsd\_ref stretch to fit entire word on one line. Also, the TX/RX buffers should be labeled to match the text}

As can be seen various signals are coming from the outside world through the FPGA into the ARM processor.
The signals from the current sensors and the the pedal will go to the ADC on the Zybo board. 
The ADC task will poll values from the ADC registers and update the $I_a$,$I_b$ and Torque reference variables.  
The UART RX and UART TX tasks are simply tasks that handle communication to a connected computer through the UART protocol.
UART TX task will read from the TX buffer and transmit the data, while the UART RX will read data coming from the connected computer and put it in the RX buffer.

\subsubsection{PWM generator}
The PWM generator is placed in the FPGA and is developed using Xilinx System Generator in Matlab Simulink.
The PWM generator is made to have an adjustable frequency and dutycycle.
It was choosen to make a center aligned PWM generator as this introduces less harmonic distortion than edge aligned PWM \cite{power_switching_converters}. 
Furthermore center aligned PWM also produces a symmetrical PWM signal, with a defined midpoint in the PWM-wave where the current can be sampled correctly.
The high limit for the counter can to be calculated for a given frequency, $f$, by the following:
$$H = L + \frac{f_{Zybo}}{f\cdot 2}$$
Where H is the high limit, L is the low limit and $f_{zybo}$ is the clock frequency of the Zynq-7010. 
The PWM counter system can be seen in figure \ref{fig:pwm_counter}.
The counter block will count up or down depending on the input. 
The output from the counter value will go into to two compare blocks along with the high and low limits.
The compare blocks will produce a high signal when the counter value is equal to the high and low limit respectively.
These signals are then fed to a an m-code blocks which contains a simple state machine which determines if the counter should count up or down.
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{graphics/counter}
	\caption[Block diagram of counter in PWM generator.]{Simulink block diagram of the counter in the PWM generator.}
	\label{fig:pwm_counter}
\end{figure}
The counter out signal can be seen in figure \ref{fig:pwm_graph}.
The counter signal is then fed into a PWM mechanism shown in figure \ref{fig:pwm}. 
The dutycycle is given to the PWM generator in the datatype u32, an integer type and therefore the dutycycle is given in a range of 0 to 1000, giving a resolution of 0.1\%.
The switching limit will be calculated from the following:
$$l = (1 - \frac{d}{1000}) \cdot r$$
Where l is switching limit, d is the dutycycle in the range 0 - 1000 and is the counter range.
A register will then make sure that the switching limit is only passed on when the counter is at its lowest.
It is important to do so as otherwise the dutycycle can be corrupted.
The compare block will make the PWM signal by comparing the switcing limit to the counter value.
The counter signal and output of the PWM generator can be seen in figure \ref{fig:pwm_graph}.
As the PWM generator should be able to do three independent PWM signal there are three of the systems shown in figure \ref{fig:pwm}, one for each phase.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{graphics/pwm_system}
	\caption[Block diagram of PWM generator.]{Simulink block diagram of the PWM mechanism in the PWM generator.}
	\label{fig:pwm}
\end{figure}


\begin{figure}[!h]
	\begin{center}
		\includegraphics[width=\linewidth]{graphics/pwm_plot}
		\caption{Counter and PWM signal.}
		\label{fig:pwm_graph}
	\end{center}
\end{figure}

\subsubsection{PWM task}
The PWM tasks basic functionality can be seen in the block diagram of figure \ref{fig:pwm_task}.
The PWM task is a seperate task from the controller task as it might be preferrable to have the two tasks run at different frequencies.
It is responsible for performing inverse Clarke Park transformation using $V_{sd}$, $V_{sq}$ and $\theta$. 
Afterwards the calculated dutycycles will be written to the PWM generator in the FPGA if the enable signal is high.

\begin{figure}[!h]
	\centering
		\includegraphics[width=0.9\linewidth,trim=2cm 17cm 0cm 4cm]{graphics/pwm_tasktikz}
	\caption[Block diagram of PWM task.]{Block diagram showing the functionality of the PWM task.}
	\label{fig:pwm_task}
\end{figure}

\todo[inline]{Where should we talk about the concept of dq and the meaning of it? -MIkkel}
\todo[inline]{Third harmonic injection and why? -MIkkel}


\subsubsection{Interface task}
The interface task is the task that has to read external signals, output digital signals and control the other tasks.
The UART tasks will be controlled through two buffers, while the controller and PWM task will have to read the enable variable updated by the interface task.
The basic funcionality of the interface task can be seen in the flowchart of figure \ref{fig:interface}.
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{graphics/interface_task}
	\caption[Block diagram of PWM generator.]{Simulink block diagram of the counter in the PWM generator.}
	\label{fig:interface}
\end{figure}
\todo[inline]{Can there be less whitespace in the figure? -MIkkel}
\todo[inline]{Is the inrush relay explained somewhere?? -MIkkel}

\subsubsection{Controller task}

\begin{figure}[!h]
	\centering
		\includegraphics[width=0.9\linewidth,trim=3cm 15cm 0 2cm]{graphics/controller_tasktikz}
	\caption[Block diagram of controller task.]{Block diagram showing the functionality of the controller task.}
	\label{fig:controller_task}
\end{figure}

The basic functionality of the controller task can be seen in figure \ref{fig:controller_task}.
\todo[inline]{This figure needs to be updated.!!}
The task polls data from the ADC in order to get raw data for $I_a$, $I_b$ and the foot pedal.
The raw data from the ADC are then calculated into voltages and the two currents are calculated based by the equation:

\begin{equation}
	 I = \frac{V_{measured}}{R_m} \cdot NS
\end{equation}
$I_c$ is calculated based on the assumption that the three currents form a balanced three phase system.
The resistance of the foot pedal potentiometer is calculated from the measured voltage and equation \ref{eq:pedal_back_calc}.

$I_a$, $I_b$, $I_c$ and $\theta$ are then used to perform a Clarke Park transformation and obtaining the values of $I_d$ and $I_q$. 

$I_d$ and $I_q$ should be controlled towards a setpoint by two seperate controllers.
The setpoint for $I_d$ is 0 as will be explained later?? .
\todo[inline]{Where?} 
The setpoint, $q_{set}$, for $I_q$ should be related to the maximum allowed current, $q_{max}$, and the position of the foot pedal in percent, $pedal_\%$:
\begin{equation}
	q_{set} = pedal_\% \cdot q_{max};
\end{equation}
It was choosen to use two PI controllers as will be described in section \ref{sec:controller_design}.
The code for one of the controllers can be seen in listing \ref{lis:controller_code}.
It can be seen that trapezoidal integration and a anti windup scheme is used. 

\begin{lstlisting}[captionpos=b,style=customCpp, caption={Something clever!.}, label=lis:controller_code]
q_error = q_set - I_q_measured;
q_integral = q_integral + (q_previous_error + q_error)*0.5*dt;

if(q_integral > MAX_TOTAL_OUTPUT){										
	q_integral = MAX_TOTAL_OUTPUT;
}else if(q_integral < -MAX_TOTAL_OUTPUT){
	q_integral = -MAX_TOTAL_OUTPUT;
}

q_output = kp * q_error + ki * q_integral;
q_previous_error = q_error;
\end{lstlisting}
In listing \ref{lis:saturation} the code for detecting and downscaling output values exceeding the maximum output can bee seen.

\begin{lstlisting}[captionpos=b,style=customCpp, caption={Something clever!.}, label=lis:saturation]
total_output_magnitude = sqrt(d_output*d_output + q_output*q_output);

if(total_output_magnitude > MAX_TOTAL_OUTPUT){
	d_output = (d_output* MAX_TOTAL_OUTPUT)/total_output_magnitude;
	q_output = (q_output* MAX_TOTAL_OUTPUT)/total_output_magnitude;
}
\end{lstlisting}




\subsubsection{ADC}
The Zynq chip contains a dual 12-bit, 1 Mega sample per second (MSPS) Analog-to-Digital Converter (ADC) \cite{adc}.
The ADC is utilized through the XADC Wizard in Vivado. 
The ADC measures the difference between differential analog input pins $V_p$ and $V_n$.
The IP core is configured to use AXI4LITE connection, simultaneous selection, unipolar mode and event mode.
Simultaneous selection mode is used as it allows simultaneous sampling on the dual ADC. 
When using simultaneous sampling the phase relationship is preserved.
When unipolar mode is enabled the input range between $V_p$ and $V_n$ is 1 \si{\volt} and the input voltage must always be positive.
Setting the ADC in event mode, means that the ADC will only sample when there is a rising edge on its CONVST pin. 
The CONVST pin is connected to the top signal of the PWM generator meaning that the ADC will sample in the center of the PWM pulse.
This is done to avoid sampling any current spikes. 
Channels 6 and 14 are paired together in simultaneous mode, meaning that they will be sampled simultaneous.
Therefore the outputs from the two LEM sensors will be connected to these. 
The torque pedal signal will be routed to channel 7 which will be sampled after channel 6 and 14.
The top signal from the PWM generator will start the sampling and therefore it will also set the sampling frequency.
As the PWM frequency is 20 \si{\kilo\hertz} the PWM frequency will be so as well.

\subsection{Encoder}
The Zybo board needs to interface the RMB28MD encoder that is mounted on the motor.
The RMB28MD is an absolute encoder with sine/cosine, SSI and incremental output. 
It was choosen to use the SSI output as an IP core reading the position by SSI communication was made available by the supervisors of the group.
Reading the position throug SSI yields a resolution of 8bit per mechanical revolution. 
The IP core outputs a clock to the RMB28MD chip and reads data from a datapin. 
It then makes the data available on the AXI4LITE bus, where it can be read from software. 

\subsection{SPI communication}

\todo[inline]{Thomas: I haven't described our timing issues, it seemed a better thing to do it in this section?}
\begin{figure}[!h]
	\centering
		\includegraphics[width=1\linewidth]{graphics/spi_timing}
	\caption[SPI timing requirements.]{SPI timing requirements.From datasheet? How to cite?}
	\label{fig:spi_timing}
\end{figure}

As described earlier the Zybo board will need to set certain parameters on the DRV8301 chip using SPI communication. 
The Zynq chip has two SPI controllers in the PS area of the chip, which can be setup to communicate with external devices.
By investigation the Zynq datasheet \cite{zynq_reference} it  was found that it was not possible to configure the SPI controller to meet the requirements of the DRV8301. 
More specifically it was not possible to configure the clock signal to go low for a minimum of 40 \si{\nano\second} \cite{DRV8301}, before Slave Select goes low. 

Two solutions were found to this problem:
\begin{enumerate}
	\item To develop a simple SPI driver in VHDL or System Generator to send 16bit according to the SPI requirements of the DRV8301.
	\item To use the SPI controller in PS of the Zynq and delay the Slave Select signal physically.
\end{enumerate}
It was found that the most correct solution to the problem would be to develop a SPI driver, but due to time considarations it was choosen to use the SPI controller of the Zynq.

SPI 1 on the Zynq was used as it can be ported to MIO channels 10 to 15, which can be accessed through the PMOD connectors of the Zybo board. 
The SPI controller was initialized in software and was configured to be in master mode, manuel chip select mode and manuel start mode by writing to the configuration register Config\_reg0.
In order to comply with the SPI specifications of the DRV8301 it was configured with the XSPIPS\_CLK\_PHASE\_1\_OPTION in order to make data valid on falling edges of the clock. 
The discharge of a capacitor is utialized to make a delay on the Slave Select signal, by putting a XX capacitor and XX resistor in series with the signal.
The transmission of \texttt{0b0001000000110000} were measured by an oscilloscope and can be seen in figure \ref{fig:spi_graph}.
\todo[inline]{can 0b0001000000110000 be written more beautifull?? :) Mikkel}

\begin{figure}[!h]
	\centering
		\includegraphics[width=1\linewidth]{graphics/spi}
	\caption[SPI transmission.]{SPI transmission of two data bytes.}
	\label{fig:spi_graph}
\end{figure}



\subsection{Timing TEST or whatever}

\todo[inline]{Write about the task frequencies}

%\subsection{Conclusion}